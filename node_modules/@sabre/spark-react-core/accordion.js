"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));
var _from = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/from"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _matches = _interopRequireDefault(require("../helpers/traversal/matches"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Accordion
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.Accordion(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/accordion.js
                                                                                                                                                                                                                                                                                                                                              * @since 2.13.0
                                                                                                                                                                                                                                                                                                                                              */
var onOpenEvent = document.createEvent('Event');
var onCloseEvent = document.createEvent('Event');
onOpenEvent.initEvent('open', true, true);
onCloseEvent.initEvent('close', true, true);

/**
 * Private Helper Method to Expand an Accordion Drawer
 * @param {String} drawer
 * @return {Promise}
 * @private
 */
var expand = function expand(drawer) {
  var _this = this;
  var self = this;
  return new _promise.default(function (resolve) {
    var control = _this.el.querySelector('.spark-accordion__header[aria-controls="' + drawer + '"]');
    var content = _this.el.querySelector('#' + drawer);
    var height = Math.round(content.scrollHeight);
    control.setAttribute('aria-expanded', true);
    content.style.visibility = 'visible';
    content.style.height = height + 'px';
    content.addEventListener('transitionend', function onExpand() {
      var _context;
      content.removeEventListener('transitionend', onExpand);
      content.style.height = (0, _includes.default)(_context = self.expanded).call(_context, drawer) ? 'auto' : 0 + 'px';
      onOpenEvent.drawer = drawer;
      self.el.dispatchEvent(onOpenEvent);
      resolve();
    });
  });
};

/**
 * Private Helper Method to Collapse an Accordion Drawer
 * @param {String} drawer
 * @return {Promise}
 * @private
 */
var collapse = function collapse(drawer) {
  var _this2 = this;
  var self = this;
  return new _promise.default(function (resolve) {
    var control = _this2.el.querySelector('.spark-accordion__header[aria-controls="' + drawer + '"]');
    var content = _this2.el.querySelector('#' + drawer);
    var height = content.scrollHeight;
    var transition = content.style.transition;
    content.style.visibility = 'visible';
    content.style.transition = '';
    content.addEventListener('transitionend', function onCollapse() {
      content.removeEventListener('transitionend', onCollapse);
      control.setAttribute('aria-expanded', false);
      content.style.visibility = 'hidden';
    });
    requestAnimationFrame(function () {
      // Define height explicitly, because transitions on "auto" won't visually animate
      content.style.height = height + 'px';

      // trigger another transition
      content.style.transition = transition;
      requestAnimationFrame(function () {
        // set height to 0, so that the transition may animate from the fixed height to 0
        content.style.height = 0 + 'px';
      });
      control.setAttribute('aria-expanded', false);
      onCloseEvent.drawer = drawer;
      self.el.dispatchEvent(onCloseEvent);
      resolve();
    });
  });
};

/**
 * Accordion
 * @class creates an Accordion
 * @extends {BaseComponent}
 */
var Accordion = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Accordion, _BaseComponent);
  var _super = _createSuper(Accordion);
  /**
   * Accordion constructor.
   * @param {Element} el
   * @param {Object} params
   * @constructor
   */
  function Accordion(el) {
    var _this3;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Accordion);
    _this3 = _super.call(this, el, params);
    _this3._bindEventListenerCallbacks();
    _this3._addEventListeners();
    if (_this3.radio) {
      _this3.multiExpand = false;
      _this3.collapsible = false;
      if (!(0, _hasClass.default)(_this3.el, 'spark-accordion--radio')) {
        (0, _addClass.default)(_this3.el, 'spark-accordion--radio');
      }
    }
    return _this3;
  }

  /**
   * Sets up references
   * @param  {Element} el base DOM element
   * @private
   */
  (0, _createClass2.default)(Accordion, [{
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      if ((0, _hasClass.default)(this.el, 'spark-accordion--radio')) {
        this.radio = true;
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     * @private
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onClickBound = this._onClick.bind(this);
      this._onKeyDownBound = this._onKeyDown.bind(this);
      this._onChangeBound = this._onChange.bind(this);
      this._onOpenBound = this._onOpen.bind(this);
      this._onCloseBound = this._onClose.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     * @private
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      if (this.el) {
        this.el.addEventListener('click', this._onClickBound, true);
        this.el.addEventListener('keydown', this._onKeyDownBound, true);
        this.el.addEventListener('change', this._onChangeBound, true);
        this.el.addEventListener('open', this._onOpenBound, true);
        this.el.addEventListener('close', this._onCloseBound, true);

        // Added as MS Hack, for enabling the addition and removal of a `focus` class,
        // to circumvent a lack of support in Internet Explorer & Edge for :focus-within
        // TODO: Remove focus/blur based event code & associated .focus CSS styles,
        // upon Edge browser support for :focus-within, and dropping of Internet Explorer
        this.el.addEventListener('focus', this._onFocusBound, true);
        this.el.addEventListener('blur', this._onBlurBound, true);
      }
    }

    /**
     * Remove event listeners for DOM events..
     * @private
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      if (this.el) {
        this.el.removeEventListener('click', this._onClickBound, true);
        this.el.removeEventListener('keydown', this._onKeyDownBound, true);
        this.el.removeEventListener('change', this._onChangeBound, true);
        this.el.removeEventListener('open', this._onOpenBound, true);
        this.el.removeEventListener('close', this._onCloseBound, true);
        this.el.removeEventListener('focus', this._onFocusBound, true);
        this.el.removeEventListener('blur', this._onBlurBound, true);
      }
    }

    /**
     * On Key Down (ENTER or ARROW UP/DOWN keys), trigger accordion controls
     * @param {Event} e
     * @private
     */
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(e) {
      var _context2, _context3;
      var ENTER_KEY_CODE = 13;
      var SPACE_KEY_CODE = 32;
      var ARROW_UP_KEY_CODE = 38;
      var ARROW_DOWN_KEY_CODE = 40;
      if (this.radio && e.keyCode !== ENTER_KEY_CODE) return;
      var control = (0, _hasClass.default)(e.target, 'spark-accordion__header') ? e.target : (0, _getParent.default)(e.target, '.spark-accordion__header', this.el);
      var drawer = control && this._isActionable(control.getAttribute('aria-controls')) ? control.getAttribute('aria-controls') : undefined;
      if (drawer) {
        switch (e.keyCode) {
          case ENTER_KEY_CODE:
          case SPACE_KEY_CODE:
            if (this.radio) {
              this.select(drawer);
            } else {
              this.toggle(drawer);
            }
            break;
          case ARROW_DOWN_KEY_CODE:
            if ((0, _includes.default)(_context2 = this.collapsed).call(_context2, drawer)) {
              this.open(drawer);
            } else {
              e.preventDefault();
            }
            break;
          case ARROW_UP_KEY_CODE:
            if ((0, _includes.default)(_context3 = this.expanded).call(_context3, drawer)) {
              this.close(drawer);
            } else {
              e.preventDefault();
            }
            break;
        }
      }
    }

    /**
     * On Click, if target is a radio control, emulate `ENTER` key for Windows Browsers
     * @params {Object} e
     * @private
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      var headerClick = (0, _hasClass.default)(e.target, 'spark-accordion__header');
      var header = headerClick ? e.target : (0, _getParent.default)(e.target, '.spark-accordion__header', this.el);
      if (header) {
        var drawer = header.getAttribute('aria-controls');
        var isActionable = this._isActionable(drawer);
        if (isActionable && this.radio) {
          this.select(drawer);
        } else if (isActionable) {
          this.toggle(drawer);
        }
      }
    }

    /**
     * On Focus, add a class for Internet Explorer styles
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onFocus",
    value: function _onFocus(e) {
      if ((0, _matches.default)(e.target, 'header')) {
        (0, _addClass.default)(e.target, 'focus');
      } else if ((0, _matches.default)(e.target, '.spark-radio__input')) {
        var header = (0, _getParent.default)(e.target, '.spark-accordion__header', this.el);
        (0, _addClass.default)(header, 'focus');
      }
    }

    /**
     * On Blur, remove class added for Internet Explorer styles
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onBlur",
    value: function _onBlur(e) {
      if ((0, _matches.default)(e.target, 'header')) {
        (0, _removeClass.default)(e.target, 'focus');
      } else if ((0, _matches.default)(e.target, '.spark-radio__input')) {
        var header = (0, _getParent.default)(e.target, '.spark-accordion__header', this.el);
        (0, _removeClass.default)(header, 'focus');
      }
    }

    /**
     * On Radio change, make sure drawers match selection
     * @param {Event} e
     * @private
     */
  }, {
    key: "_onChange",
    value: function _onChange(e) {
      if ((0, _matches.default)(e.target, '.spark-accordion__header > .spark-radio > .spark-radio__input')) {
        var _context4;
        var header = (0, _getParent.default)(e.target, '.spark-accordion__header', this.el);
        var drawer = header && (0, _includes.default)(_context4 = this.drawers).call(_context4, header.getAttribute('aria-controls')) ? header.getAttribute('aria-controls') : undefined;
        if (drawer) this.select(drawer);
      }
    }

    /**
     * Fire `onOpen` callback
     * @param {Event} e
     * @private
     */
  }, {
    key: "_onOpen",
    value: function _onOpen(e) {
      this.onOpen.call(this, e);
    }

    /**
     * Fire `onClose` callback
     * @param {Event} e
     * @private
     */
  }, {
    key: "_onClose",
    value: function _onClose(e) {
      this.onClose.call(this, e);
    }

    /**
     * Returns whether or not a drawer exists, and itâ€™s current expanded/collapsed state can be changed
     * @param {String} drawer
     * @return {Boolean}
     * @private
     */
  }, {
    key: "_isActionable",
    value: function _isActionable(drawer) {
      var _context5, _context6, _context7;
      var isExpanded = (0, _includes.default)(_context5 = this.expanded).call(_context5, drawer);
      var isCollapsed = (0, _includes.default)(_context6 = this.collapsed).call(_context6, drawer);
      if (!(0, _includes.default)(_context7 = this.drawers).call(_context7, drawer)) {
        return false;
      } else if (this.radio) {
        var radio = this.el.querySelector('.spark-accordion__header[aria-controls="' + drawer + '"] .spark-radio .spark-radio__input');
        return radio && !radio.checked && !radio.hasAttribute('disabled') ? true : false;
      } else if (!this.collapsible) {
        if (isExpanded && this.expanded.length === 1) {
          return false;
        } else if (isExpanded && this.expanded.length > 1) {
          return true;
        } else if (isCollapsed) {
          return true;
        }
      } else if (!this.multiExpand) {
        if (isExpanded && this.collapsible) {
          return true;
        } else if (!this.collapsible && isExpanded) {
          return false;
        } else if (isCollapsed) {
          return true;
        }
      } else {
        return true;
      }
    }

    /**
     * Return collection of all drawers
     * @return {Array}
     * @public
     */
  }, {
    key: "drawers",
    get: function get() {
      var _context8;
      var drawerControls = this.el.querySelectorAll('.spark-accordion__header');
      var drawerContents = this.el.querySelectorAll('.spark-accordion__content');
      var drawerNames = drawerControls.length ? (0, _map.default)(_context8 = (0, _from.default)(drawerControls)).call(_context8, function (control) {
        return control.getAttribute('aria-controls');
      }) : [];
      return (0, _filter.default)(drawerNames).call(drawerNames, function (drawer) {
        return (0, _from.default)(drawerContents).some(function (content) {
          return content.id === drawer;
        });
      });
    }

    /**
     * Return collection of currently expanded drawers
     * @return {Array}
     * @public
     */
  }, {
    key: "expanded",
    get: function get() {
      var _context9;
      var openDrawerControls = this.el.querySelectorAll('.spark-accordion__header[aria-expanded="true"]');
      return openDrawerControls.length ? (0, _map.default)(_context9 = (0, _from.default)(openDrawerControls)).call(_context9, function (control) {
        return control.getAttribute('aria-controls');
      }) : [];
    }

    /**
     * Explicitly set which drawers are currently expanded
     * @param {Array} drawers
     * @public
     */,
    set: function set(drawers) {
      var _this4 = this;
      if (!this.radio) {
        var _context10;
        var toClose = (0, _filter.default)(_context10 = this.expanded).call(_context10, function (expanded) {
          return !(0, _includes.default)(drawers).call(drawers, expanded);
        });
        toClose.forEach(function (drawer) {
          return _this4.close(drawer).catch(function () {});
        });
        drawers.forEach(function (drawer) {
          return _this4.open(drawer).catch(function () {});
        });
      } else if (drawers.length >= 1) {
        this.select(drawers.pop());
      }
    }

    /**
     * Return collection of currently collapsed drawers
     * @return {Array}
     * @public
     */
  }, {
    key: "collapsed",
    get: function get() {
      var _context11;
      var openDrawerControls = this.el.querySelectorAll('.spark-accordion__header[aria-expanded="false"]');
      return openDrawerControls.length ? (0, _map.default)(_context11 = (0, _from.default)(openDrawerControls)).call(_context11, function (control) {
        return control.getAttribute('aria-controls');
      }) : [];
    }

    /**
     * Explicitly set which drawers are currently expanded
     * @param {Array} drawers
     * @public
     */,
    set: function set(drawers) {
      var _this5 = this;
      if (!this.radio) {
        var _context12;
        var toOpen = (0, _filter.default)(_context12 = this.collapsed).call(_context12, function (collapsed) {
          return !(0, _includes.default)(drawers).call(drawers, collapsed);
        });
        toOpen.forEach(function (drawer) {
          return _this5.open(drawer).catch(function () {});
        });
        drawers.forEach(function (drawer) {
          return _this5.close(drawer).catch(function () {});
        });
      } else {
        throw new Error('Cannot be used to control radio accordions');
      }
    }

    /**
     * Returns the current radio value
     * @return {String}
     * @public
     */
  }, {
    key: "selected",
    get: function get() {
      if (!this.radio) {
        return undefined;
      } else {
        var checkedRadio = this.el.querySelector('.spark-accordion__header .spark-radio > .spark-radio__input:checked');
        return checkedRadio ? checkedRadio.value : undefined;
      }
    }

    /**
     * Activate an accordion drawer by radio value
     * @param {String} value
     * @public
     */,
    set: function set(value) {
      if (!this.radio) {
        return;
      } else if (!value) {
        this.clearValue();
      } else {
        var _context13;
        var radio = this.el.querySelector('.spark-accordion__header .spark-radio > .spark-radio__input[value="' + value + '"]');
        var drawer = (0, _getParent.default)(radio, '.spark-accordion__header', this.el).getAttribute('aria-controls');
        if ((0, _includes.default)(_context13 = this.drawers).call(_context13, drawer)) this.select(drawer);
      }
    }

    /**
     * Expand accordion drawer
     * @param {String} drawer
     * @return {Promise}
     * @public
     */
  }, {
    key: "open",
    value: function open(drawer) {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        var drawers = self.drawers;
        var expanded = self.expanded;
        var collapsed = self.collapsed;
        var isActionable = self._isActionable(drawer);
        if (!(0, _includes.default)(drawers).call(drawers, drawer)) {
          reject(new Error('Drawer either does not exist, or configured incorrectly'));
        } else if ((0, _includes.default)(expanded).call(expanded, drawer)) {
          resolve();
        } else if ((0, _includes.default)(collapsed).call(collapsed, drawer) && !isActionable) {
          reject(new Error('Drawer could not be opened'));
        } else if ((0, _includes.default)(collapsed).call(collapsed, drawer) && isActionable && self.radio) {
          self.select(drawer).then(resolve);
        } else if ((0, _includes.default)(collapsed).call(collapsed, drawer) && isActionable && self.multiExpand) {
          expand.call(self, drawer).then(resolve);
        } else if ((0, _includes.default)(collapsed).call(collapsed, drawer) && isActionable && !self.multiExpand) {
          if (expanded.length > 0) {
            collapse.call(self, expanded[0]).then(function () {
              expand.call(self, drawer).then(resolve);
            });
          } else {
            expand.call(self, drawer).then(resolve);
          }
        } else {
          resolve();
        }
      });
    }

    /**
     * Collapse accordion drawer
     * @param {String} drawer
     * @return {Promise}
     * @public
     */
  }, {
    key: "close",
    value: function close(drawer) {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        var drawers = self.drawers;
        var expanded = self.expanded;
        var collapsed = self.collapsed;
        var isActionable = self._isActionable(drawer);
        if (!(0, _includes.default)(drawers).call(drawers, drawer)) {
          reject(new Error('Drawer either does not exist, or configured incorrectly'));
        } else if ((0, _includes.default)(collapsed).call(collapsed, drawer)) {
          resolve();
        } else if ((0, _includes.default)(expanded).call(expanded, drawer) && !isActionable) {
          reject(new Error('Drawer could not be closed'));
        } else if (isActionable) {
          collapse.call(self, drawer).then(resolve);
        } else {
          resolve();
        }
      });
    }

    /**
     * Tell the accordion to toggle drawer if drawer is valid
     * @param {String} drawer
     * @public
     */
  }, {
    key: "toggle",
    value: function toggle(drawer) {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        var _context14, _context15, _context16, _context17, _context18;
        var isActionable = self._isActionable(drawer);
        if (!(0, _includes.default)(_context14 = self.drawers).call(_context14, drawer)) {
          reject(new Error('Drawer either does not exist, or configured incorrectly'));
        } else if (self.radio && isActionable) {
          self.clearValue().then(function () {
            return self.select(drawer);
          }).then(resolve).catch(function () {
            reject(new Error('Radio Drawer could not be opened'));
          });
        } else if ((0, _includes.default)(_context15 = self.expanded).call(_context15, drawer) && isActionable) {
          self.close(drawer).then(resolve);
        } else if ((0, _includes.default)(_context16 = self.expanded).call(_context16, drawer) && !isActionable) {
          reject(new Error('Drawer could not be closed'));
        } else if ((0, _includes.default)(_context17 = self.collapsed).call(_context17, drawer) && isActionable) {
          if (self.multiExpand) {
            self.open(drawer).then(resolve);
          } else {
            self.hide().then(function () {
              self.open(drawer).then(resolve);
            });
          }
        } else if ((0, _includes.default)(_context18 = self.collapsed).call(_context18, drawer) && !isActionable) {
          reject(new Error('Drawer could not be opened'));
        }
      });
    }

    /**
     * Check radio
     * @param {String} drawer
     * @return {Promise}
     * @public
     */
  }, {
    key: "select",
    value: function select(drawer) {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        var _context19;
        if (self.radio && drawer === self.expanded[0]) {
          resolve();
        } else if (self.radio && (0, _includes.default)(_context19 = self.drawers).call(_context19, drawer)) {
          var radio = self.el.querySelector('.spark-accordion__header[aria-controls="' + drawer + '"] .spark-radio__input:enabled');
          if (radio) {
            self.clearValue().then(function () {
              radio.checked = true;
              expand.call(self, drawer).then(resolve);
            });
          } else {
            reject(new Error('Cannot select radio button "' + drawer + '"'));
          }
        } else {
          reject(new Error('Not a radio accordion'));
        }
      });
    }

    /**
     * Uncheck all radios and collapse open drawers - only works for Radio Accordions
     * @return {Promise}
     * @public
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      var self = this;
      return new _promise.default(function (resolve) {
        if (self.radio && self.expanded.length) {
          var drawer = self.expanded[0];
          var radio = self.el.querySelector('.spark-accordion__header[aria-controls="' + drawer + '"] .spark-radio__input');
          radio.checked = false;
          collapse.call(self, drawer).then(resolve);
        } else if (!self.radio) {
          console.info('clearValue() only effects radio accordions, but was run anyway');
        } else {
          resolve();
        }
      });
    }

    /**
     * Expand all drawers (Chevron - `multiExpand`) or enable radio buttons (Radio)
     * @return {Promise}
     * @public
     */
  }, {
    key: "show",
    value: function show() {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        if (self.radio) {
          var radioButtons = self.el.querySelectorAll('.spark-accordion__header .spark-radio__input');
          if (radioButtons.length >= 1) {
            radioButtons.forEach(function (radio) {
              return radio.removeAttribute('disabled');
            });
            resolve();
          } else {
            reject(new Error('Accordion is either misconfigured, or there are no drawers to enable'));
          }
        } else if (self.multiExpand) {
          var collapsed = self.collapsed;
          switch (collapsed.length) {
            case 0:
              resolve();
              break;
            case 1:
              expand.call(self, collapsed[0]).then(resolve);
              break;
            default:
              {
                var changes = [];
                do {
                  changes.push(expand.call(self, collapsed.shift()));
                } while (collapsed.length);
                _promise.default.all(changes).then(resolve).catch(reject);
                break;
              }
          }
        } else {
          var expanded = self.expanded;
          if (expanded.length && expanded[0] !== self.drawers[0]) {
            collapse.call(self, expanded[0]);
            expand.call(self, self.drawers[0]).then(resolve);
          } else if (expanded.length) {
            resolve();
          } else {
            reject(new Error('Accordion is either misconfigured, or there are no drawers to open'));
          }
        }
      });
    }

    /**
     * Collapse all drawers (Chevron) or disable radio buttons (radio)
     * @return {Promise}
     * @public
     */
  }, {
    key: "hide",
    value: function hide() {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        if (self.radio) {
          var radioButtons = self.el.querySelectorAll('.spark-accordion__header .spark-radio__input');
          if (radioButtons.length >= 1) {
            radioButtons.forEach(function (button) {
              var disabled = document.createAttribute('disabled');
              button.attributes.setNamedItem(disabled);
            });
            resolve();
          } else {
            reject(new Error('Accordion is either misconfigured, or there are no drawers to disable'));
          }
        } else {
          var expanded = self.expanded;
          switch (expanded.length) {
            case 0:
              resolve();
              break;
            case 1:
              collapse.call(self, expanded[0]).then(resolve);
              break;
            default:
              {
                var changes = [];
                do {
                  changes.push(collapse.call(self, expanded.shift()));
                } while (expanded.length);
                _promise.default.all(changes).then(resolve).catch(reject);
                break;
              }
          }
        }
      });
    }

    /**
     * Remove component from DOM.
     * @param {Boolean} leaveElement
     * @public
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(Accordion.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the element in use and the position.
     * @param {Element} el
     * @public
     */
  }, {
    key: "update",
    value: function update(el, params) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(Accordion.prototype), "update", this).call(this, el, params);
    }
  }]);
  return Accordion;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Accordion.prototype._whitelistedParams = ['radio', 'multiExpand', 'collapsible', 'onOpen', 'onClose'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Accordion.prototype.defaults = {
  el: null,
  radio: false,
  multiExpand: true,
  collapsible: true,
  onOpen: function onOpen() {},
  onClose: function onClose() {}
};
var _default = Accordion;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=accordion.js.map
